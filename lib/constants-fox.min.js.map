{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///constants-fox.min.js","webpack:///webpack/bootstrap 8688d61d5eb94cf02970","webpack:///./src/constants.js","webpack:///./src/helpers.js","webpack:///./~/eventemitter3/index.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","global","apply","undefined","_eventemitter","_helpers","fs","_interopRequireWildcard","obj","__esModule","newObj","key","Object","prototype","hasOwnProperty","_interopRequireDefault","default","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","defineProperty","_eventemitter2","Utils","_typeof","Symbol","iterator","_createClass","defineProperties","target","props","i","length","descriptor","protoProps","staticProps","Constants","_EventEmitter","options","_this","getPrototypeOf","_previous","defaults","storage","local","sync","env","initialized","assign","once","set","detectContext","initialize","bind","_this2","_initializeStorageValues","emit","callback","isNode","mockChromeApiWithFileSystem","isChromeExtension","chrome","isBrowser","Error","mockChromeApiWithLocalStorage","constants","writeFileSync","JSON","stringify","get","hash","response","_key","item","parse","readFileSync","_response","_item","items","_constants","remove","saved","_saved","clear","localStorage","getItem","_response2","setItem","removeItem","_assign","storageSlug","toJSON","_this3","vals","keys","forEach","_this4","Function","isChrome","storageEnabled","index","arguments","source","EE","fn","context","EventEmitter","has","prefix","_events","eventNames","name","events","names","push","slice","getOwnPropertySymbols","concat","listeners","event","exists","evt","available","l","ee","Array","a1","a2","a3","a4","a5","args","len","removeListener","j","on","listener","removeAllListeners","off","addListener","setMaxListeners","prefixed"],"mappings":"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","file":"constants-fox.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"constants-fox\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"constants-fox\"] = factory();\n\telse\n\t\troot[\"constants-fox\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"constants-fox\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"constants-fox\"] = factory();\n\telse\n\t\troot[\"constants-fox\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(1);\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {\n\t  if (true) {\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(3), __webpack_require__(2), __webpack_require__(4)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t  } else if (typeof exports !== \"undefined\") {\n\t    factory(exports, require('eventemitter3'), require('./helpers'), require('fs'));\n\t  } else {\n\t    var mod = {\n\t      exports: {}\n\t    };\n\t    factory(mod.exports, global.eventemitter3, global.helpers, global.fs);\n\t    global.constants = mod.exports;\n\t  }\n\t})(this, function (exports, _eventemitter, _helpers, fs) {\n\t  'use strict';\n\t\n\t  Object.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t  });\n\t\n\t  var _eventemitter2 = _interopRequireDefault(_eventemitter);\n\t\n\t  var Utils = _interopRequireWildcard(_helpers);\n\t\n\t  function _interopRequireWildcard(obj) {\n\t    if (obj && obj.__esModule) {\n\t      return obj;\n\t    } else {\n\t      var newObj = {};\n\t\n\t      if (obj != null) {\n\t        for (var key in obj) {\n\t          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n\t        }\n\t      }\n\t\n\t      newObj.default = obj;\n\t      return newObj;\n\t    }\n\t  }\n\t\n\t  function _interopRequireDefault(obj) {\n\t    return obj && obj.__esModule ? obj : {\n\t      default: obj\n\t    };\n\t  }\n\t\n\t  var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n\t    return typeof obj;\n\t  } : function (obj) {\n\t    return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj;\n\t  };\n\t\n\t  function _classCallCheck(instance, Constructor) {\n\t    if (!(instance instanceof Constructor)) {\n\t      throw new TypeError(\"Cannot call a class as a function\");\n\t    }\n\t  }\n\t\n\t  var _createClass = function () {\n\t    function defineProperties(target, props) {\n\t      for (var i = 0; i < props.length; i++) {\n\t        var descriptor = props[i];\n\t        descriptor.enumerable = descriptor.enumerable || false;\n\t        descriptor.configurable = true;\n\t        if (\"value\" in descriptor) descriptor.writable = true;\n\t        Object.defineProperty(target, descriptor.key, descriptor);\n\t      }\n\t    }\n\t\n\t    return function (Constructor, protoProps, staticProps) {\n\t      if (protoProps) defineProperties(Constructor.prototype, protoProps);\n\t      if (staticProps) defineProperties(Constructor, staticProps);\n\t      return Constructor;\n\t    };\n\t  }();\n\t\n\t  function _possibleConstructorReturn(self, call) {\n\t    if (!self) {\n\t      throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n\t    }\n\t\n\t    return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n\t  }\n\t\n\t  function _inherits(subClass, superClass) {\n\t    if (typeof superClass !== \"function\" && superClass !== null) {\n\t      throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n\t    }\n\t\n\t    subClass.prototype = Object.create(superClass && superClass.prototype, {\n\t      constructor: {\n\t        value: subClass,\n\t        enumerable: false,\n\t        writable: true,\n\t        configurable: true\n\t      }\n\t    });\n\t    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n\t  }\n\t\n\t  var Constants = function (_EventEmitter) {\n\t    _inherits(Constants, _EventEmitter);\n\t\n\t    function Constants(options) {\n\t      _classCallCheck(this, Constants);\n\t\n\t      var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Constants).call(this));\n\t\n\t      _this._previous = {};\n\t      _this.defaults = {};\n\t      _this.storage = {\n\t        local: {},\n\t        sync: {}\n\t      };\n\t      _this.env = null;\n\t      _this.initialized = false;\n\t\n\t      Object.assign(_this.defaults, options);\n\t      _this.once('ready', function () {\n\t        _this.set(options);\n\t      });\n\t      _this.detectContext(_this.initialize.bind(_this));\n\t      return _this;\n\t    }\n\t\n\t    _createClass(Constants, [{\n\t      key: 'initialize',\n\t      value: function initialize() {\n\t        var _this2 = this;\n\t\n\t        this._initializeStorageValues(function () {\n\t          if (_this2.initialized) {\n\t            _this2.emit('reset');\n\t            return;\n\t          }\n\t          _this2.initialized = true;\n\t          _this2.emit('ready');\n\t        });\n\t      }\n\t    }, {\n\t      key: 'detectContext',\n\t      value: function detectContext(callback) {\n\t        // TODO: add a delete or clear function so that storage can be reset\n\t        if (Utils.isNode()) {\n\t          this.storage = this.mockChromeApiWithFileSystem();\n\t          this.env = 'node';\n\t        } else if (Utils.isChromeExtension()) {\n\t          this.storage.local = chrome.storage.local;\n\t          this.env = 'chrome';\n\t        } else if (Utils.isBrowser()) {\n\t          this.storage = this.mockChromeApiWithLocalStorage();\n\t          this.env = 'browser';\n\t        } else {\n\t          throw new Error('Cannot detect JavaScript context');\n\t        }\n\t        if (callback) {\n\t          return callback();\n\t        }\n\t      }\n\t    }, {\n\t      key: 'mockChromeApiWithFileSystem',\n\t      value: function mockChromeApiWithFileSystem() {\n\t        var constants = this;\n\t        fs.writeFileSync('./src/constants.json', JSON.stringify(this.defaults), 'utf8');\n\t        return {\n\t          local: {\n\t            get: function get(key, callback) {\n\t              if (typeof callback !== 'function') {\n\t                throw new Error('\"storage.get\" expects a callback');\n\t              }\n\t              if ((typeof key === 'undefined' ? 'undefined' : _typeof(key)) === 'object') {\n\t                var hash = key;\n\t                var response = {};\n\t                for (var _key in hash) {\n\t                  var item = JSON.parse(fs.readFileSync('./src/constants.json'))[_key];\n\t                  if (item) {\n\t                    response[_key] = item;\n\t                  } else {\n\t                    this[_key] = hash[_key];\n\t                    response[_key] = this[_key];\n\t                  }\n\t                }\n\t                return callback(response);\n\t              } else if (typeof key === 'string') {\n\t                var _response = {};\n\t                var _item = JSON.parse(fs.readFileSync('./src/constants.json'))[key];\n\t                if (_item) {\n\t                  _response[key] = _item;\n\t                }\n\t                return callback(_response);\n\t              }\n\t            },\n\t            set: function set(items, callback) {\n\t              if ((typeof items === 'undefined' ? 'undefined' : _typeof(items)) !== 'object') {\n\t                throw new Error('\"storage.set\" expects an object');\n\t              } else {\n\t                var _constants = JSON.parse(fs.readFileSync('./src/constants.json'));\n\t                for (var key in items) {\n\t                  if ({}.hasOwnProperty.call(items, key)) {\n\t                    _constants[key] = items[key];\n\t                  }\n\t                }\n\t                fs.writeFileSync('./src/constants.json', JSON.stringify(_constants));\n\t                if (callback) {\n\t                  callback();\n\t                }\n\t              }\n\t            },\n\t            remove: function remove(key, callback) {\n\t              if (typeof key === 'string') {\n\t                var saved = JSON.parse(fs.readFileSync('./src/constants.json'));\n\t                delete saved[key];\n\t                delete constants[key];\n\t                fs.writeFileSync('./src/constants.json', JSON.stringify(saved));\n\t                if (callback) {\n\t                  callback();\n\t                }\n\t              } else if ((typeof key === 'undefined' ? 'undefined' : _typeof(key)) === 'object') {\n\t                var items = key;\n\t                var _saved = JSON.parse(fs.readFileSync('./src/constants.json'));\n\t                for (var _key in items) {\n\t                  if ({}.hasOwnProperty.call(constants, _key)) {\n\t                    delete _saved[_key];\n\t                    delete constants[_key];\n\t                  }\n\t                }\n\t                fs.writeFileSync('./src/constants.json', JSON.stringify(constants));\n\t                if (callback) {\n\t                  callback();\n\t                }\n\t              }\n\t            },\n\t            clear: function clear() {\n\t              for (var key in constants) {\n\t                if ({}.hasOwnProperty.call(constants, key) && typeof constants[key] !== 'function') {\n\t                  this.remove(key);\n\t                  delete constants[key];\n\t                }\n\t              }\n\t            }\n\t          }\n\t        };\n\t      }\n\t    }, {\n\t      key: 'mockChromeApiWithLocalStorage',\n\t      value: function mockChromeApiWithLocalStorage() {\n\t        var constants = this;\n\t        return {\n\t          local: {\n\t            get: function get(key, callback) {\n\t              if (typeof callback !== 'function') {\n\t                throw new Error('\"storage.get\" expects a callback');\n\t              }\n\t              if ((typeof key === 'undefined' ? 'undefined' : _typeof(key)) === 'object') {\n\t                var hash = key;\n\t                var response = {};\n\t                for (var _key in hash) {\n\t                  var item = localStorage.getItem(_key);\n\t                  response[_key] = item;\n\t                }\n\t                return callback(response);\n\t              } else if (typeof key === 'string') {\n\t                var _response2 = {};\n\t                _response2[key] = localStorage.getItem(key);\n\t                return callback(_response2);\n\t              }\n\t            },\n\t            set: function set(items, callback) {\n\t              if ((typeof items === 'undefined' ? 'undefined' : _typeof(items)) !== 'object') {\n\t                throw new Error('\"storage.set\" expects an object');\n\t              } else {\n\t                for (var key in items) {\n\t                  if ({}.hasOwnProperty.call(items, key)) {\n\t                    localStorage.setItem(key, items[key]);\n\t                  }\n\t                }\n\t                if (callback) {\n\t                  callback();\n\t                }\n\t              }\n\t            },\n\t            remove: function remove(key, callback) {\n\t              if (typeof key === 'string') {\n\t                localStorage.removeItem(key);\n\t                delete constants[key];\n\t                if (callback) {\n\t                  callback();\n\t                }\n\t              } else if ((typeof key === 'undefined' ? 'undefined' : _typeof(key)) === 'object') {\n\t                var items = key;\n\t                for (var _key in items) {\n\t                  localStorage.removeItem(_key);\n\t                  delete constants[_key];\n\t                }\n\t                if (callback) {\n\t                  callback();\n\t                }\n\t              }\n\t            },\n\t            clear: function clear() {\n\t              for (var key in constants) {\n\t                if ({}.hasOwnProperty.call(constants, key) && typeof constants[key] !== 'function') {\n\t                  localStorage.removeItem(key);\n\t                  delete constants[key];\n\t                }\n\t              }\n\t            }\n\t          }\n\t        };\n\t      }\n\t    }, {\n\t      key: 'clear',\n\t      value: function clear() {\n\t        this.storage.local.clear();\n\t      }\n\t    }, {\n\t      key: 'get',\n\t      value: function get(key) {\n\t        if ((typeof key === 'undefined' ? 'undefined' : _typeof(key)) === 'object') {\n\t          var response = {};\n\t          var hash = key;\n\t          for (var _key in hash) {\n\t            if ({}.hasOwnProperty.call(hash, _key) && this[_key]) {\n\t              response[_key] = this[_key];\n\t            }\n\t          }\n\t          return response;\n\t        } else if (typeof key === 'string') {\n\t          return this[key];\n\t        }\n\t      }\n\t    }, {\n\t      key: 'set',\n\t      value: function set(key, value) {\n\t        if ((typeof key === 'undefined' ? 'undefined' : _typeof(key)) === 'object') {\n\t          this._assign(key);\n\t          this.storage.local.set(key);\n\t        } else {\n\t          this[key] = value;\n\t          var storageSlug = {}; // NOTE: you need to use this pattern in order to programmatically set chrome storage key value pairs\n\t          storageSlug[key] = value;\n\t          this.storage.local.set(storageSlug);\n\t        }\n\t        this.emit('change', this.toJSON);\n\t      }\n\t    }, {\n\t      key: 'remove',\n\t      value: function remove(key) {\n\t        return this.storage.local.remove(key);\n\t      }\n\t    }, {\n\t      key: 'previous',\n\t      value: function previous(key) {\n\t        if (!key) {\n\t          return this._previous;\n\t        }\n\t        return this._previous[key];\n\t      }\n\t    }, {\n\t      key: 'reset',\n\t      value: function reset() {\n\t        this.set(this.defaults);\n\t        this.initialize();\n\t      }\n\t    }, {\n\t      key: 'toJSON',\n\t      value: function toJSON() {\n\t        var _this3 = this;\n\t\n\t        var vals = {};\n\t        Object.keys(this.defaults).forEach(function (key) {\n\t          vals[key] = _this3[key];\n\t        });\n\t        return Object.assign({}, vals);\n\t      }\n\t    }, {\n\t      key: '_assign',\n\t      value: function _assign(items) {\n\t        for (var key in items) {\n\t          if ({}.hasOwnProperty.call(items, key)) {\n\t            if (typeof this.key === 'undefined') {\n\t              this._previous[key] = items[key]; // we'll assume here this is on initialization\n\t            } else {\n\t              this._previous[key] = this[key];\n\t            }\n\t            this[key] = items[key];\n\t          }\n\t        }\n\t      }\n\t    }, {\n\t      key: '_initializeStorageValues',\n\t      value: function _initializeStorageValues(callback) {\n\t        var _this4 = this;\n\t\n\t        this.storage.local.get(this.defaults, function (items) {\n\t          Object.assign(_this4, items);\n\t          if (callback) {\n\t            callback();\n\t          }\n\t        });\n\t      }\n\t    }]);\n\t\n\t    return Constants;\n\t  }(_eventemitter2.default);\n\t\n\t  exports.default = Constants;\n\t});\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {\n\t  if (true) {\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t  } else if (typeof exports !== \"undefined\") {\n\t    factory(exports);\n\t  } else {\n\t    var mod = {\n\t      exports: {}\n\t    };\n\t    factory(mod.exports);\n\t    global.helpers = mod.exports;\n\t  }\n\t})(this, function (exports) {\n\t  \"use strict\";\n\t\n\t  Object.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t  });\n\t  var isBrowser = exports.isBrowser = new Function(\"try {return window;}catch(e){ return false;}\");\n\t  var isChrome = exports.isChrome = new Function(\"try {return ('chrome' in window);}catch(e){return false;}\");\n\t  var isNode = exports.isNode = new Function(\"try {return process.title;}catch(e){return false;}\");\n\t  var storageEnabled = exports.storageEnabled = new Function(\"typeof chrome.storage !== 'undefined'\");\n\t  var isChromeExtension = exports.isChromeExtension = function isChromeExtension() {\n\t    return isBrowser() && isChrome() && storageEnabled();\n\t  };\n\t\n\t  if (typeof Object.assign !== 'function') {\n\t    Object.assign = function (target) {\n\t      'use strict';\n\t\n\t      if (target === null) {\n\t        throw new TypeError('Cannot convert undefined or null to object');\n\t      }\n\t\n\t      target = Object(target);\n\t      for (var index = 1; index < arguments.length; index++) {\n\t        var source = arguments[index];\n\t        if (source !== null) {\n\t          for (var key in source) {\n\t            if (Object.prototype.hasOwnProperty.call(source, key)) {\n\t              target[key] = source[key];\n\t            }\n\t          }\n\t        }\n\t      }\n\t      return target;\n\t    };\n\t  }\n\t});\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar has = Object.prototype.hasOwnProperty;\n\t\n\t//\n\t// We store our EE objects in a plain object whose properties are event names.\n\t// If `Object.create(null)` is not supported we prefix the event names with a\n\t// `~` to make sure that the built-in object properties are not overridden or\n\t// used as an attack vector.\n\t// We also assume that `Object.create(null)` is available when the event name\n\t// is an ES6 Symbol.\n\t//\n\tvar prefix = typeof Object.create !== 'function' ? '~' : false;\n\t\n\t/**\n\t * Representation of a single EventEmitter function.\n\t *\n\t * @param {Function} fn Event handler to be called.\n\t * @param {Mixed} context Context for function execution.\n\t * @param {Boolean} [once=false] Only emit once\n\t * @api private\n\t */\n\tfunction EE(fn, context, once) {\n\t  this.fn = fn;\n\t  this.context = context;\n\t  this.once = once || false;\n\t}\n\t\n\t/**\n\t * Minimal EventEmitter interface that is molded against the Node.js\n\t * EventEmitter interface.\n\t *\n\t * @constructor\n\t * @api public\n\t */\n\tfunction EventEmitter() { /* Nothing to set */ }\n\t\n\t/**\n\t * Hold the assigned EventEmitters by name.\n\t *\n\t * @type {Object}\n\t * @private\n\t */\n\tEventEmitter.prototype._events = undefined;\n\t\n\t/**\n\t * Return an array listing the events for which the emitter has registered\n\t * listeners.\n\t *\n\t * @returns {Array}\n\t * @api public\n\t */\n\tEventEmitter.prototype.eventNames = function eventNames() {\n\t  var events = this._events\n\t    , names = []\n\t    , name;\n\t\n\t  if (!events) return names;\n\t\n\t  for (name in events) {\n\t    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n\t  }\n\t\n\t  if (Object.getOwnPropertySymbols) {\n\t    return names.concat(Object.getOwnPropertySymbols(events));\n\t  }\n\t\n\t  return names;\n\t};\n\t\n\t/**\n\t * Return a list of assigned event listeners.\n\t *\n\t * @param {String} event The events that should be listed.\n\t * @param {Boolean} exists We only need to know if there are listeners.\n\t * @returns {Array|Boolean}\n\t * @api public\n\t */\n\tEventEmitter.prototype.listeners = function listeners(event, exists) {\n\t  var evt = prefix ? prefix + event : event\n\t    , available = this._events && this._events[evt];\n\t\n\t  if (exists) return !!available;\n\t  if (!available) return [];\n\t  if (available.fn) return [available.fn];\n\t\n\t  for (var i = 0, l = available.length, ee = new Array(l); i < l; i++) {\n\t    ee[i] = available[i].fn;\n\t  }\n\t\n\t  return ee;\n\t};\n\t\n\t/**\n\t * Emit an event to all registered event listeners.\n\t *\n\t * @param {String} event The name of the event.\n\t * @returns {Boolean} Indication if we've emitted an event.\n\t * @api public\n\t */\n\tEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n\t  var evt = prefix ? prefix + event : event;\n\t\n\t  if (!this._events || !this._events[evt]) return false;\n\t\n\t  var listeners = this._events[evt]\n\t    , len = arguments.length\n\t    , args\n\t    , i;\n\t\n\t  if ('function' === typeof listeners.fn) {\n\t    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\t\n\t    switch (len) {\n\t      case 1: return listeners.fn.call(listeners.context), true;\n\t      case 2: return listeners.fn.call(listeners.context, a1), true;\n\t      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n\t      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n\t      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n\t      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n\t    }\n\t\n\t    for (i = 1, args = new Array(len -1); i < len; i++) {\n\t      args[i - 1] = arguments[i];\n\t    }\n\t\n\t    listeners.fn.apply(listeners.context, args);\n\t  } else {\n\t    var length = listeners.length\n\t      , j;\n\t\n\t    for (i = 0; i < length; i++) {\n\t      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\t\n\t      switch (len) {\n\t        case 1: listeners[i].fn.call(listeners[i].context); break;\n\t        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n\t        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n\t        default:\n\t          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n\t            args[j - 1] = arguments[j];\n\t          }\n\t\n\t          listeners[i].fn.apply(listeners[i].context, args);\n\t      }\n\t    }\n\t  }\n\t\n\t  return true;\n\t};\n\t\n\t/**\n\t * Register a new EventListener for the given event.\n\t *\n\t * @param {String} event Name of the event.\n\t * @param {Function} fn Callback function.\n\t * @param {Mixed} [context=this] The context of the function.\n\t * @api public\n\t */\n\tEventEmitter.prototype.on = function on(event, fn, context) {\n\t  var listener = new EE(fn, context || this)\n\t    , evt = prefix ? prefix + event : event;\n\t\n\t  if (!this._events) this._events = prefix ? {} : Object.create(null);\n\t  if (!this._events[evt]) this._events[evt] = listener;\n\t  else {\n\t    if (!this._events[evt].fn) this._events[evt].push(listener);\n\t    else this._events[evt] = [\n\t      this._events[evt], listener\n\t    ];\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Add an EventListener that's only called once.\n\t *\n\t * @param {String} event Name of the event.\n\t * @param {Function} fn Callback function.\n\t * @param {Mixed} [context=this] The context of the function.\n\t * @api public\n\t */\n\tEventEmitter.prototype.once = function once(event, fn, context) {\n\t  var listener = new EE(fn, context || this, true)\n\t    , evt = prefix ? prefix + event : event;\n\t\n\t  if (!this._events) this._events = prefix ? {} : Object.create(null);\n\t  if (!this._events[evt]) this._events[evt] = listener;\n\t  else {\n\t    if (!this._events[evt].fn) this._events[evt].push(listener);\n\t    else this._events[evt] = [\n\t      this._events[evt], listener\n\t    ];\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Remove event listeners.\n\t *\n\t * @param {String} event The event we want to remove.\n\t * @param {Function} fn The listener that we need to find.\n\t * @param {Mixed} context Only remove listeners matching this context.\n\t * @param {Boolean} once Only remove once listeners.\n\t * @api public\n\t */\n\tEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n\t  var evt = prefix ? prefix + event : event;\n\t\n\t  if (!this._events || !this._events[evt]) return this;\n\t\n\t  var listeners = this._events[evt]\n\t    , events = [];\n\t\n\t  if (fn) {\n\t    if (listeners.fn) {\n\t      if (\n\t           listeners.fn !== fn\n\t        || (once && !listeners.once)\n\t        || (context && listeners.context !== context)\n\t      ) {\n\t        events.push(listeners);\n\t      }\n\t    } else {\n\t      for (var i = 0, length = listeners.length; i < length; i++) {\n\t        if (\n\t             listeners[i].fn !== fn\n\t          || (once && !listeners[i].once)\n\t          || (context && listeners[i].context !== context)\n\t        ) {\n\t          events.push(listeners[i]);\n\t        }\n\t      }\n\t    }\n\t  }\n\t\n\t  //\n\t  // Reset the array, or remove it completely if we have no more listeners.\n\t  //\n\t  if (events.length) {\n\t    this._events[evt] = events.length === 1 ? events[0] : events;\n\t  } else {\n\t    delete this._events[evt];\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Remove all listeners or only the listeners for the specified event.\n\t *\n\t * @param {String} event The event want to remove all listeners for.\n\t * @api public\n\t */\n\tEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n\t  if (!this._events) return this;\n\t\n\t  if (event) delete this._events[prefix ? prefix + event : event];\n\t  else this._events = prefix ? {} : Object.create(null);\n\t\n\t  return this;\n\t};\n\t\n\t//\n\t// Alias methods names because people roll like that.\n\t//\n\tEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\tEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\t\n\t//\n\t// This function doesn't apply anymore.\n\t//\n\tEventEmitter.prototype.setMaxListeners = function setMaxListeners() {\n\t  return this;\n\t};\n\t\n\t//\n\t// Expose the prefix.\n\t//\n\tEventEmitter.prefixed = prefix;\n\t\n\t//\n\t// Expose the module.\n\t//\n\tif (true) {\n\t  module.exports = EventEmitter;\n\t}\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** constants-fox.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 8688d61d5eb94cf02970\n **/","import EventEmitter from 'eventemitter3';\nimport * as Utils from './helpers';\n\nconst fs = require('fs');\n\nexport default class Constants extends EventEmitter {\n  _previous = {};\n  defaults = {};\n  storage = {\n    local: {},\n    sync: {}\n  };\n  env = null;\n  initialized = false;\n\n  constructor(options) {\n    super();\n    Object.assign(this.defaults, options);\n    this.once('ready', () => {\n      this.set(options);\n    });\n    this.detectContext(::this.initialize);\n  }\n\n  initialize() {\n    this._initializeStorageValues(() => {\n      if (this.initialized) {\n        this.emit('reset');\n        return;\n      }\n      this.initialized = true;\n      this.emit('ready');\n    });\n  }\n\n  detectContext(callback) { // TODO: add a delete or clear function so that storage can be reset\n    if (Utils.isNode()) {\n      this.storage = this.mockChromeApiWithFileSystem();\n      this.env = 'node';\n    } else if (Utils.isChromeExtension()) {\n      this.storage.local = chrome.storage.local;\n      this.env = 'chrome';\n    } else if (Utils.isBrowser()) {\n      this.storage = this.mockChromeApiWithLocalStorage();\n      this.env = 'browser';\n    } else {\n      throw new Error('Cannot detect JavaScript context');\n    }\n    if (callback) {\n      return callback();\n    }\n  }\n\n  mockChromeApiWithFileSystem() {\n    const constants = this;\n    fs.writeFileSync('./src/constants.json', JSON.stringify(this.defaults), 'utf8');\n    return {\n      local: {\n        get(key, callback) {\n          if (typeof callback !== 'function') {\n            throw new Error('\"storage.get\" expects a callback');\n          }\n          if (typeof key === 'object') {\n            const hash = key;\n            const response = {};\n            for (const _key in hash) {\n              const item = JSON.parse(fs.readFileSync('./src/constants.json'))[_key];\n              if (item) {\n                response[_key] = item;\n              } else {\n                this[_key] = hash[_key];\n                response[_key] = this[_key];\n              }\n            }\n            return callback(response);\n          } else if (typeof key === 'string') {\n            const response = {};\n            const item = JSON.parse(fs.readFileSync('./src/constants.json'))[key];\n            if (item) {\n              response[key] = item;\n            }\n            return callback(response);\n          }\n        },\n        set(items, callback) {\n          if (typeof items !== 'object') {\n            throw new Error('\"storage.set\" expects an object');\n          } else {\n            const constants = JSON.parse(fs.readFileSync('./src/constants.json'));\n            for (const key in items) {\n              if ({}.hasOwnProperty.call(items, key)) {\n                constants[key] = items[key];\n              }\n            }\n            fs.writeFileSync('./src/constants.json', JSON.stringify(constants));\n            if (callback) {\n              callback();\n            }\n          }\n        },\n        remove(key, callback) {\n          if (typeof key === 'string') {\n            const saved = JSON.parse(fs.readFileSync('./src/constants.json'));\n            delete saved[key];\n            delete constants[key];\n            fs.writeFileSync('./src/constants.json', JSON.stringify(saved));\n            if (callback) {\n              callback();\n            }\n          } else if (typeof key === 'object') {\n            const items = key;\n            const saved = JSON.parse(fs.readFileSync('./src/constants.json'));\n            for (const _key in items) {\n              if ({}.hasOwnProperty.call(constants, _key)) {\n                delete saved[_key];\n                delete constants[_key];\n              }\n            }\n            fs.writeFileSync('./src/constants.json', JSON.stringify(constants));\n            if (callback) {\n              callback();\n            }\n          }\n        },\n        clear() {\n          for (const key in constants) {\n            if ({}.hasOwnProperty.call(constants, key) && typeof constants[key] !== 'function') {\n              this.remove(key);\n              delete constants[key];\n            }\n          }\n        }\n      }\n    }\n  }\n\n  mockChromeApiWithLocalStorage() {\n    const constants = this;\n    return {\n      local: {\n        get(key, callback) {\n          if (typeof callback !== 'function') {\n            throw new Error('\"storage.get\" expects a callback');\n          }\n          if (typeof key === 'object') {\n            const hash = key;\n            const response = {};\n            for (const _key in hash) {\n              const item = localStorage.getItem(_key);\n              response[_key] = item;\n            }\n            return callback(response);\n          } else if (typeof key === 'string') {\n            const response = {};\n            response[key] = localStorage.getItem(key);\n            return callback(response);\n          }\n        },\n        set(items, callback) {\n          if (typeof items !== 'object') {\n            throw new Error('\"storage.set\" expects an object');\n          } else {\n            for (const key in items) {\n              if ({}.hasOwnProperty.call(items, key)) {\n                localStorage.setItem(key, items[key]);\n              }\n            }\n            if (callback) {\n              callback();\n            }\n          }\n        },\n        remove(key, callback) {\n          if (typeof key === 'string') {\n            localStorage.removeItem(key);\n            delete constants[key];\n            if (callback) {\n              callback();\n            }\n          } else if (typeof key === 'object') {\n            const items = key;\n            for (const _key in items) {\n              localStorage.removeItem(_key);\n              delete constants[_key];\n            }\n            if (callback) {\n              callback();\n            }\n          }\n        },\n        clear() {\n          for (const key in constants) {\n            if ({}.hasOwnProperty.call(constants, key) && typeof constants[key] !== 'function') {\n              localStorage.removeItem(key);\n              delete constants[key];\n            }\n          }\n        }\n      }\n    }\n  }\n\n  clear() {\n    this.storage.local.clear();\n  }\n\n  get(key) {\n    if (typeof key === 'object') {\n      const response = {};\n      const hash = key;\n      for (const _key in hash) {\n        if ({}.hasOwnProperty.call(hash, _key) && this[_key]) {\n          response[_key] = this[_key];\n        }\n      }\n      return response;\n    } else if (typeof key === 'string') {\n      return this[key];\n    }\n  }\n\n  set(key, value) {\n    if (typeof key === 'object') {\n      this._assign(key);\n      this.storage.local.set(key);\n    } else {\n      this[key] = value;\n      const storageSlug = {}; // NOTE: you need to use this pattern in order to programmatically set chrome storage key value pairs\n      storageSlug[key] = value;\n      this.storage.local.set(storageSlug);\n    }\n    this.emit('change', this.toJSON);\n  }\n\n  remove(key) {\n    return this.storage.local.remove(key)\n  }\n\n  previous(key) {\n    if (!key) {\n      return this._previous;\n    }\n    return this._previous[key];\n  }\n\n  reset() {\n    this.set(this.defaults);\n    this.initialize();\n  }\n\n  toJSON() {\n    const vals = {};\n    Object.keys(this.defaults).forEach(key => {\n      vals[key] = this[key];\n    });\n    return Object.assign({}, vals);\n  }\n\n  _assign(items) {\n    for (const key in items) {\n      if ({}.hasOwnProperty.call(items, key)) {\n        if (typeof this.key === 'undefined') {\n          this._previous[key] = items[key]; // we'll assume here this is on initialization\n        } else {\n          this._previous[key] = this[key];\n        }\n        this[key] = items[key];\n      }\n    }\n  }\n\n  _initializeStorageValues(callback) {\n    this.storage.local.get(this.defaults, items => {\n      Object.assign(this, items);\n      if (callback) {\n        callback();\n      }\n    });\n  }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/constants.js\n **/","export const isBrowser = new Function(\"try {return window;}catch(e){ return false;}\");\nexport const isChrome = new Function(\"try {return ('chrome' in window);}catch(e){return false;}\");\nexport const isNode = new Function(\"try {return process.title;}catch(e){return false;}\");\nexport const storageEnabled = new Function(\"typeof chrome.storage !== 'undefined'\");\nexport const isChromeExtension = () => isBrowser() && isChrome() && storageEnabled();\n\nif (typeof Object.assign !== 'function') {\n  Object.assign = function(target) {\n    'use strict';\n    if (target === null) {\n      throw new TypeError('Cannot convert undefined or null to object');\n    }\n\n    target = Object(target);\n    for (var index = 1; index < arguments.length; index++) {\n      var source = arguments[index];\n      if (source !== null) {\n        for (var key in source) {\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n          }\n        }\n      }\n    }\n    return target;\n  };\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/helpers.js\n **/","'use strict';\n\nvar has = Object.prototype.hasOwnProperty;\n\n//\n// We store our EE objects in a plain object whose properties are event names.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// `~` to make sure that the built-in object properties are not overridden or\n// used as an attack vector.\n// We also assume that `Object.create(null)` is available when the event name\n// is an ES6 Symbol.\n//\nvar prefix = typeof Object.create !== 'function' ? '~' : false;\n\n/**\n * Representation of a single EventEmitter function.\n *\n * @param {Function} fn Event handler to be called.\n * @param {Mixed} context Context for function execution.\n * @param {Boolean} [once=false] Only emit once\n * @api private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Minimal EventEmitter interface that is molded against the Node.js\n * EventEmitter interface.\n *\n * @constructor\n * @api public\n */\nfunction EventEmitter() { /* Nothing to set */ }\n\n/**\n * Hold the assigned EventEmitters by name.\n *\n * @type {Object}\n * @private\n */\nEventEmitter.prototype._events = undefined;\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @api public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var events = this._events\n    , names = []\n    , name;\n\n  if (!events) return names;\n\n  for (name in events) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return a list of assigned event listeners.\n *\n * @param {String} event The events that should be listed.\n * @param {Boolean} exists We only need to know if there are listeners.\n * @returns {Array|Boolean}\n * @api public\n */\nEventEmitter.prototype.listeners = function listeners(event, exists) {\n  var evt = prefix ? prefix + event : event\n    , available = this._events && this._events[evt];\n\n  if (exists) return !!available;\n  if (!available) return [];\n  if (available.fn) return [available.fn];\n\n  for (var i = 0, l = available.length, ee = new Array(l); i < l; i++) {\n    ee[i] = available[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Emit an event to all registered event listeners.\n *\n * @param {String} event The name of the event.\n * @returns {Boolean} Indication if we've emitted an event.\n * @api public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events || !this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if ('function' === typeof listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Register a new EventListener for the given event.\n *\n * @param {String} event Name of the event.\n * @param {Function} fn Callback function.\n * @param {Mixed} [context=this] The context of the function.\n * @api public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  var listener = new EE(fn, context || this)\n    , evt = prefix ? prefix + event : event;\n\n  if (!this._events) this._events = prefix ? {} : Object.create(null);\n  if (!this._events[evt]) this._events[evt] = listener;\n  else {\n    if (!this._events[evt].fn) this._events[evt].push(listener);\n    else this._events[evt] = [\n      this._events[evt], listener\n    ];\n  }\n\n  return this;\n};\n\n/**\n * Add an EventListener that's only called once.\n *\n * @param {String} event Name of the event.\n * @param {Function} fn Callback function.\n * @param {Mixed} [context=this] The context of the function.\n * @api public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  var listener = new EE(fn, context || this, true)\n    , evt = prefix ? prefix + event : event;\n\n  if (!this._events) this._events = prefix ? {} : Object.create(null);\n  if (!this._events[evt]) this._events[evt] = listener;\n  else {\n    if (!this._events[evt].fn) this._events[evt].push(listener);\n    else this._events[evt] = [\n      this._events[evt], listener\n    ];\n  }\n\n  return this;\n};\n\n/**\n * Remove event listeners.\n *\n * @param {String} event The event we want to remove.\n * @param {Function} fn The listener that we need to find.\n * @param {Mixed} context Only remove listeners matching this context.\n * @param {Boolean} once Only remove once listeners.\n * @api public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events || !this._events[evt]) return this;\n\n  var listeners = this._events[evt]\n    , events = [];\n\n  if (fn) {\n    if (listeners.fn) {\n      if (\n           listeners.fn !== fn\n        || (once && !listeners.once)\n        || (context && listeners.context !== context)\n      ) {\n        events.push(listeners);\n      }\n    } else {\n      for (var i = 0, length = listeners.length; i < length; i++) {\n        if (\n             listeners[i].fn !== fn\n          || (once && !listeners[i].once)\n          || (context && listeners[i].context !== context)\n        ) {\n          events.push(listeners[i]);\n        }\n      }\n    }\n  }\n\n  //\n  // Reset the array, or remove it completely if we have no more listeners.\n  //\n  if (events.length) {\n    this._events[evt] = events.length === 1 ? events[0] : events;\n  } else {\n    delete this._events[evt];\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners or only the listeners for the specified event.\n *\n * @param {String} event The event want to remove all listeners for.\n * @api public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  if (!this._events) return this;\n\n  if (event) delete this._events[prefix ? prefix + event : event];\n  else this._events = prefix ? {} : Object.create(null);\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// This function doesn't apply anymore.\n//\nEventEmitter.prototype.setMaxListeners = function setMaxListeners() {\n  return this;\n};\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/eventemitter3/index.js\n ** module id = 3\n ** module chunks = 0\n **/"],"sourceRoot":""}